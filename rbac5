import requests
from requests.auth import HTTPBasicAuth
import json
import time
from typing import Dict, List, Optional, Union

class ConfluentRoleBindingManager:
    """
    Gestionnaire de Role Bindings pour Confluent Cloud
    Inspir√© du provider Terraform confluent_role_binding
    """
    
    def __init__(self, api_key: str, api_secret: str):
        self.base_url = "https://api.confluent.cloud"
        self.auth = HTTPBasicAuth(api_key, api_secret)
        self.headers = {'Accept': 'application/json', 'Content-Type': 'application/json'}
    
    def create_role_binding(
        self, 
        principal: str, 
        role_name: str, 
        crn_pattern: str,
        disable_wait_for_ready: bool = False
    ) -> Dict:
        """
        Cr√©er un role binding
        
        Args:
            principal: Principal √† lier (ex: "User:u-111aaa" ou "User:sa-111aaa")
            role_name: Nom du r√¥le (ex: "CloudClusterAdmin", "EnvironmentAdmin")
            crn_pattern: Pattern CRN d√©finissant la port√©e
            disable_wait_for_ready: D√©sactiver l'attente de propagation
        
        Returns:
            Dict contenant les d√©tails du role binding cr√©√©
        """
        payload = {
            "principal": principal,
            "role_name": role_name,
            "crn_pattern": crn_pattern
        }
        
        print(f"üîÑ Cr√©ation du role binding...")
        print(f"   Principal: {principal}")
        print(f"   Role: {role_name}")
        print(f"   CRN: {crn_pattern}")
        
        try:
            response = requests.post(
                f"{self.base_url}/iam/v2/role-bindings",
                json=payload,
                auth=self.auth,
                headers=self.headers
            )
            
            if response.status_code == 201:
                role_binding = response.json()
                binding_id = role_binding.get('id')
                print(f"‚úÖ Role binding cr√©√© avec succ√®s: {binding_id}")
                
                # Attendre la propagation si demand√© (comportement Terraform par d√©faut)
                if not disable_wait_for_ready:
                    print(f"‚è≥ Attente de la propagation (90s)...")
                    self._wait_for_ready(binding_id, timeout=90)
                
                return role_binding
            else:
                error_msg = f"Erreur lors de la cr√©ation: {response.status_code} - {response.text}"
                print(f"‚ùå {error_msg}")
                raise Exception(error_msg)
                
        except Exception as e:
            print(f"üí• Erreur: {e}")
            raise
    
    def get_role_binding(self, binding_id: str) -> Optional[Dict]:
        """R√©cup√©rer un role binding par ID"""
        try:
            response = requests.get(
                f"{self.base_url}/iam/v2/role-bindings/{binding_id}",
                auth=self.auth,
                headers=self.headers
            )
            
            if response.status_code == 200:
                return response.json()
            elif response.status_code == 404:
                return None
            else:
                raise Exception(f"Erreur API: {response.status_code} - {response.text}")
                
        except Exception as e:
            print(f"Erreur lors de la r√©cup√©ration: {e}")
            return None
    
    def list_role_bindings(
        self, 
        principal: Optional[str] = None,
        role_name: Optional[str] = None,
        crn_pattern: Optional[str] = None
    ) -> List[Dict]:
        """
        Lister les role bindings avec filtres optionnels
        (√âquivalent du data source terraform)
        """
        params = {}
        if principal:
            params['principal'] = principal
        if role_name:
            params['role_name'] = role_name  
        if crn_pattern:
            params['crn_pattern'] = crn_pattern
        
        try:
            response = requests.get(
                f"{self.base_url}/iam/v2/role-bindings",
                params=params,
                auth=self.auth,
                headers=self.headers
            )
            
            if response.status_code == 200:
                data = response.json()
                return data.get('data', [])
            else:
                print(f"Erreur lors de la liste: {response.status_code} - {response.text}")
                return []
                
        except Exception as e:
            print(f"Erreur: {e}")
            return []
    
    def delete_role_binding(self, binding_id: str) -> bool:
        """Supprimer un role binding"""
        try:
            response = requests.delete(
                f"{self.base_url}/iam/v2/role-bindings/{binding_id}",
                auth=self.auth,
                headers=self.headers
            )
            
            if response.status_code == 204:
                print(f"‚úÖ Role binding {binding_id} supprim√© avec succ√®s")
                return True
            else:
                print(f"‚ùå Erreur lors de la suppression: {response.status_code} - {response.text}")
                return False
                
        except Exception as e:
            print(f"Erreur: {e}")
            return False
    
    def _wait_for_ready(self, binding_id: str, timeout: int = 90):
        """Attendre que le role binding soit propag√© (comme Terraform)"""
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            binding = self.get_role_binding(binding_id)
            if binding:
                # En th√©orie, on pourrait v√©rifier un statut, mais l'API ne l'expose pas
                # Terraform fait juste une attente fixe de 90s
                time.sleep(5)
                break
            time.sleep(2)
        
        elapsed = time.time() - start_time
        print(f"‚úÖ Propagation termin√©e apr√®s {elapsed:.1f}s")

class ConfluentResourceHelper:
    """Helper pour construire les CRN patterns comme dans Terraform"""
    
    @staticmethod
    def organization_crn(org_id: str) -> str:
        """CRN pour l'organisation enti√®re"""
        return f"crn://confluent.cloud/organization={org_id}"
    
    @staticmethod
    def environment_crn(org_id: str, env_id: str) -> str:
        """CRN pour un environnement sp√©cifique"""
        return f"crn://confluent.cloud/organization={org_id}/environment={env_id}"
    
    @staticmethod
    def kafka_cluster_crn(org_id: str, env_id: str, cluster_id: str) -> str:
        """CRN pour un cluster Kafka sp√©cifique"""
        return f"crn://confluent.cloud/organization={org_id}/environment={env_id}/cloud-cluster={cluster_id}"
    
    @staticmethod
    def kafka_topic_crn(org_id: str, env_id: str, cluster_id: str, topic_name: str = "*") -> str:
        """CRN pour un/des topic(s) Kafka"""
        return f"crn://confluent.cloud/organization={org_id}/environment={env_id}/cloud-cluster={cluster_id}/kafka={cluster_id}/topic={topic_name}"
    
    @staticmethod
    def kafka_consumer_group_crn(org_id: str, env_id: str, cluster_id: str, consumer_group: str = "*") -> str:
        """CRN pour un/des consumer group(s) Kafka"""
        return f"crn://confluent.cloud/organization={org_id}/environment={env_id}/cloud-cluster={cluster_id}/kafka={cluster_id}/group={consumer_group}"
    
    @staticmethod
    def kafka_transactional_id_crn(org_id: str, env_id: str, cluster_id: str, transactional_id: str = "*") -> str:
        """CRN pour un/des transactional ID(s) Kafka"""
        return f"crn://confluent.cloud/organization={org_id}/environment={env_id}/cloud-cluster={cluster_id}/kafka={cluster_id}/transactional-id={transactional_id}"

# Exemples d'utilisation (inspir√©s des exemples Terraform)
def example_usage():
    """Exemples d'utilisation inspir√©s des configurations Terraform avec focus Consumer Groups"""
    
    # Initialisation
    manager = ConfluentRoleBindingManager(
        api_key="VOTRE_API_KEY",
        api_secret="VOTRE_API_SECRET"
    )
    
    # IDs de vos ressources (√† adapter selon votre environnement)
    org_id = "1111aaaa-11aa-11aa-11aa-111111aaaaaa"
    env_id = "env-aaa1111"
    cluster_id = "lkc-1111aaa"
    service_account_id = "sa-111aaa"
    user_id = "u-111aaa"
    
    helper = ConfluentResourceHelper()
    
    print("=== ROLE BINDINGS POUR KAFKA COMPLET (TOPICS + CONSUMER GROUPS) ===\n")
    
    # Configuration pour un d√©veloppeur complet (Read + Write + Consumer Groups)
    print("üöÄ CONFIGURATION D√âVELOPPEUR COMPLET")
    print("="*50)
    
    try:
        # 1. DeveloperWrite pour les topics
        print("\n1. üìù DeveloperWrite pour les topics")
        topic_write_binding = manager.create_role_binding(
            principal=f"User:{service_account_id}",
            role_name="DeveloperWrite",
            crn_pattern=helper.kafka_topic_crn(org_id, env_id, cluster_id, "*")
        )
        print(f"   ‚úÖ Topic Write: {topic_write_binding.get('id')}")
        
        # 2. DeveloperRead pour les topics  
        print("\n2. üìñ DeveloperRead pour les topics")
        topic_read_binding = manager.create_role_binding(
            principal=f"User:{service_account_id}",
            role_name="DeveloperRead",
            crn_pattern=helper.kafka_topic_crn(org_id, env_id, cluster_id, "*")
        )
        print(f"   ‚úÖ Topic Read: {topic_read_binding.get('id')}")
        
        # 3. DeveloperRead pour les consumer groups (NOUVEAU !)
        print("\n3. üë• DeveloperRead pour les consumer groups")
        consumer_group_binding = manager.create_role_binding(
            principal=f"User:{service_account_id}",
            role_name="DeveloperRead", 
            crn_pattern=helper.kafka_consumer_group_crn(org_id, env_id, cluster_id, "*")
        )
        print(f"   ‚úÖ Consumer Groups: {consumer_group_binding.get('id')}")
        
        # 4. (Optionnel) DeveloperWrite pour les transactional IDs si n√©cessaire
        print("\n4. üîÑ DeveloperWrite pour les transactional IDs (optionnel)")
        tx_id_binding = manager.create_role_binding(
            principal=f"User:{service_account_id}",
            role_name="DeveloperWrite",
            crn_pattern=helper.kafka_transactional_id_crn(org_id, env_id, cluster_id, "*")
        )
        print(f"   ‚úÖ Transactional IDs: {tx_id_binding.get('id')}")
        
    except Exception as e:
        print(f"‚ùå Erreur lors de la cr√©ation: {e}")
    
    print("\n" + "="*60 + "\n")
    
    # V√©rification des permissions cr√©√©es
    print("üîç V√âRIFICATION DES PERMISSIONS")
    print("-"*40)
    
    bindings = manager.list_role_bindings(principal=f"User:{service_account_id}")
    print(f"Total role bindings pour {service_account_id}: {len(bindings)}")
    
    # Grouper par type de ressource
    topic_bindings = []
    consumer_group_bindings = []
    tx_id_bindings = []
    other_bindings = []
    
    for binding in bindings:
        crn = binding.get('crn_pattern', '')
        role = binding.get('role_name', '')
        
        if '/topic=' in crn:
            topic_bindings.append(f"{role} sur topics")
        elif '/group=' in crn:
            consumer_group_bindings.append(f"{role} sur consumer groups")
        elif '/transactional-id=' in crn:
            tx_id_bindings.append(f"{role} sur transactional IDs")
        else:
            other_bindings.append(f"{role} sur {crn}")
    
    print(f"\nüìä R√©partition des permissions:")
    print(f"   Topics: {len(topic_bindings)} ({', '.join(topic_bindings)})")
    print(f"   Consumer Groups: {len(consumer_group_bindings)} ({', '.join(consumer_group_bindings)})")
    print(f"   Transactional IDs: {len(tx_id_bindings)} ({', '.join(tx_id_bindings)})")
    print(f"   Autres: {len(other_bindings)}")
    
    # R√©sum√© pour le d√©veloppeur
    print(f"\nüéØ R√âSUM√â POUR LE D√âVELOPPEUR:")
    print(f"Avec ces permissions, le service account {service_account_id} peut:")
    if topic_bindings:
        if any('Write' in b for b in topic_bindings):
            print(f"   ‚úÖ Produire des messages vers tous les topics")
        if any('Read' in b for b in topic_bindings):
            print(f"   ‚úÖ Lire des messages depuis tous les topics")
    
    if consumer_group_bindings:
        print(f"   ‚úÖ Rejoindre et utiliser tous les consumer groups")
    else:
        print(f"   ‚ö†Ô∏è  MANQUE: Permissions consumer groups (d'o√π votre erreur!)")
    
    if tx_id_bindings:
        print(f"   ‚úÖ Utiliser les transactions Kafka")
    
    print(f"\n‚úÖ Configuration termin√©e!")

def fix_consumer_group_permissions():
    """Script sp√©cifique pour r√©soudre le probl√®me des consumer groups"""
    
    manager = ConfluentRoleBindingManager(
        api_key="VOTRE_API_KEY",
        api_secret="VOTRE_API_SECRET"
    )
    
    # IDs de vos ressources (REMPLACEZ par vos vrais IDs)
    org_id = "VOTRE_ORG_ID"  # Format: 1111aaaa-11aa-11aa-11aa-111111aaaaaa
    env_id = "VOTRE_ENV_ID"   # Format: env-aaa1111
    cluster_id = "VOTRE_CLUSTER_ID"  # Format: lkc-1111aaa
    service_account_id = "VOTRE_SA_ID"  # Format: sa-111aaa
    
    helper = ConfluentResourceHelper()
    
    print("=== R√âSOLUTION DU PROBL√àME CONSUMER GROUPS ===\n")
    
    print("üéØ Probl√®me identifi√©:")
    print('   "No role DeveloperRead for ressource type ConsumerGroup"')
    print("   ‚Üí Il manque les permissions pour les consumer groups\n")
    
    print("üí° Solution:")
    print("   Ajouter un role binding DeveloperRead pour les consumer groups\n")
    
    try:
        # Cr√©er le role binding manquant pour les consumer groups
        consumer_group_crn = helper.kafka_consumer_group_crn(org_id, env_id, cluster_id, "*")
        
        print(f"üîß Cr√©ation du role binding pour consumer groups...")
        print(f"   Principal: User:{service_account_id}")
        print(f"   Role: DeveloperRead")
        print(f"   CRN: {consumer_group_crn}")
        
        binding = manager.create_role_binding(
            principal=f"User:{service_account_id}",
            role_name="DeveloperRead",
            crn_pattern=consumer_group_crn
        )
        
        print(f"\n‚úÖ Role binding cr√©√© avec succ√®s!")
        print(f"   ID: {binding.get('id')}")
        print(f"   Votre application peut maintenant utiliser les consumer groups!")
        
    except Exception as e:
        print(f"‚ùå Erreur: {e}")
        print(f"\nüîç V√©rifiez:")
        print(f"   - Vos IDs sont corrects (org_id, env_id, cluster_id, service_account_id)")
        print(f"   - Votre API key a les permissions pour cr√©er des role bindings")
        print(f"   - Le service account existe bien")

if __name__ == "__main__":
    print("Choisissez une option:")
    print("1. Exemples complets (topics + consumer groups)")
    print("2. R√©solution rapide du probl√®me consumer groups")
    
    choice = input("\nVotre choix (1 ou 2): ").strip()
    
    if choice == "2":
        fix_consumer_group_permissions()
    else:
        example_usage()
